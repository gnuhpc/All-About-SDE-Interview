排列DFS套路：
传入参数：
1. 原数据集
2. 已经访问过的记录 (why？ 因为不能有重复的) 这是和组合不一样的套路
3. 临时结果集
4. 最终结果集

函数内的处理逻辑：
1. 判断退出条件
2. 遍历每个数字，选择过的跳过，否则加入临时结果集。然后递归进入，传入的内容一样。
3. 然后回溯，将标记去掉，并从临时结果集中去掉最后的那个元素

LC相关题目：
46, 47, 60


求组合是对原元素集合抽取一些作为结果集合，结果集合中没有什么顺序, 不能重复

组合DFS套路：
出入参数
1. 原数据集
2. 从哪里开始（因为无序不要重复，同时还要剔除已经用过的，因此要一直往前找，这个就是从哪里开始往前找的依据）
3. 临时结果集
4. 最终结果集

函数内的处理逻辑：
1. 判断退出条件，处理临时结果加入到最终结果
2. 遍历每个数字，加入临时结果集,然后递归进入，
   除了** start向后一个 **（因为已经选择过了,**这是重点**）,其余传入的内容一样
3. 然后回溯，从临时结果集中去掉最后的那个元素

LC相关题目：
77, 78,39 (如果不剔除已经用过的，则start是i)



比较：从定义上，“有序”与“无序”是区别排列与组合的重要标志，具体区别是
1. 排列结果集大小和原始数据集一样，而组合不是，组合是挑一些
2. 排列的结果同一数据集不同顺序就是不一样，而组合不是,组合结果里面的数据集是无序的. 举个例子：
   [1,2,3] [2,1,3]两个数据集在排列里面都可能是结果的一部分，但是在组合里同一个结果集。
   因此在实现上，
   组合有一个遍历到哪的start，通过dfs进行递进，不但要排除已经用过的，还有不能整体重复。
   而排列不需要，排列有一个visited数组记录下用没用过就行。

1. 如果希望记录一路以来的中间结果，则可以不进行退出条件的判断而直接将临时结果集加入到最终结果集中
LC相关题目
78

2. 排列中如果原数据集有重复元素，先进行排序，然后再加入临时数据集之前进行如下判断
    if(i>0 && nums[i]==nums[i-1] && !visited[i-1])   {
        continue;
    }
