什么时候使用BFS：
图 的遍 历 Traversal in Graph
• 层级遍历 Level Order Traversal
• 由点及面 Connected Component
• 拓扑排序 Topological Sorting
最短路径 Shortest Path in Simple Graph
• 仅限简单图求最短路径
• 即，图中每条边长度都是1，且没有方向

BFS的过程
1. 构建队列
2. 将要遍历的结构中的起始遍历元素放入队列中, 如果可能绕回来,则注意他同时维护visited数组对其进行已访问标识
3. 进入遍历循环, 条件为!queue.isEmpty()
    3.0 这个时候的queue size是这一层的元素的个数,如果需要计数可以在这一步进行, 同时也可以维护一个depth在这一步++进行层数的记录
            //关键地方，queue的大小即为这一层有多少个节点。
            int size = queue.size();
            //那么在轮询的时候即按照这个大小来轮询这一层的节点
    3.1 取出该元素
    3.2 遍历该元素的邻居, 进行运算后或者判断有必要后续再处理的则放入队列中,同时设置visited


LC相关题目
102
429
107
637
139

1. BFS可以做计步
    class WordNode {
        String word;
        int numSteps;
        WordNode pre;

        public WordNode(String word, int numSteps, WordNode pre) {
            this.word = word;
            this.numSteps = numSteps;
            this.pre = pre;
        }
    }

往下回溯用最后一个节点即可,另外numsteps在每一层+1 , 维护unvisited和visited,在明确到下一层的时候将unvisited更新

LC相关题目
126
127

2. BFS过去实际上是最短路径，可以通过map<Node, Integer> 进行标注节点和对应的step，完事儿用DFS进行汇总
LC相关题目
126
127
433

3. 双向BFS适用于知道起点和终点，求之间最短路径的情况
step1: 构建起点终点的集合，将起点和终点分别加入
step2: 递归双向BFS，构建每个单词的层级对应关系
    // 始终以少的进行探索
    // 在已访问的单词集合中去除
    // 标记本层是否已到达目标单词
    // 记录本层所访问的单词

LC相关题目
126
127

4. 在while循环刚进入的时候维护一个depth在这一步++进行层数的记录
LC相关题目
127
433

5. 在求最短、最小等问题时需要遍历最短、最小的情况但是又不想往下一层遍历，可以在while循环中设置found变量，当找到后将此变量设置为true，碰到
found == true的时候就continue直到queue弹出所有的结果，这一层遍历完毕。
LC相关题目
301

6. 在计算距离的时候可以使用坐标+到这点的距离放入queue中进行BFS
Queue<int[]> queue = new LinkedList<>();
queue.add(new int[] {i, j, 0});

poll出来后使用一个数组进行记录:distances[x][y] += dist; //更新d
然后再遍历外围一层的时候 queue.add(new int[] {newX, newY, dist + 1});
Or use an array to memo the distance

LC相关题目
317, 286
