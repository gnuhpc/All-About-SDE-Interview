先看单调栈

单调栈
单调栈分为单调递增栈和单调递减栈
11. 单调递增栈即栈内元素保持单调递增的栈
12. 同理单调递减栈即栈内元素保持单调递减的栈

操作规则（下面都以单调递增栈为例）
21. 如果新的元素比栈顶元素大，就入栈
22. 如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小

加入这样一个规则之后，会有什么效果
31. 栈内的元素是递增的
32. 当元素出栈时，说明这个新元素是出栈元素向后找第一个比其小的元素

https://pic.leetcode-cn.com/7e876ae756613053b3432cebc9274e9dbdaafd2e6b8492d37fc34ee98f7655ea-%E5%9B%BE%E7%89%87.png
举个例子，配合下图，现在索引在 6 ，栈里是 1 5 6 。
接下来新元素是 2 ，那么 6 需要出栈。
当 6 出栈时，右边 2 代表是 6 右边第一个比 6 小的元素。

33. 当元素出栈后，说明新栈顶元素是出栈元素向前找第一个比其小的元素
当 6 出栈时，5 成为新的栈顶，那么 5 就是 6 左边第一个比 6 小的元素。

代码模板
单调递增栈： 找最小的时候用
        Deque<Integer> s = new LinkedList<>();
        int i = 0;
        while (i < heights.length) {
            if (s.isEmpty() || nums[s.peek()] <= nums[i])//可能会更大，因此往后走
                s.push(i++);//如果只关注数值可以直接存入数值，如果关注idx之间的距离，也就是和最值的距离，则存入idx
            else {
                tp = s.pop();  // store the top index
                做处理
            }
        }

        while (!s.isEmpty()) {
            tp = s.pop();
        }

单调递递减：找最大的时候用
        Deque<Integer> s = new LinkedList<>();
        int i = 0;
        while (i < heights.length) {
            if (s.isEmpty() || nums[i] > nums[s.peek()])//可能会更大，因此往后走
                s.push(i++);//如果只关注数值可以直接存入数值，如果关注idx之间的距离，也就是和最值的距离，则存入idx
            else {
                tp = s.pop();  // store the top index
                做处理
            }
        }

        while (!s.isEmpty()) {
            tp = s.pop();
        }


LC相关题目：
496 (递减栈)
84 （递增栈）
