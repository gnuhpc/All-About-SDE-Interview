单调栈

性质：栈内元素都是单调递增或者单调递减

举个生动的例子来说明吧：比如有一天，某家店在发 free food，很多人在排队，于是你也赶过去凑热闹。
但是由于来晚了，队伍已经很长了，想着不然就插个队啥的。但发现排在队伍最前面的都是一些有纹身的大佬，惹不起，只能赞美道，
小猪佩奇身上纹，来世还做社会人。于是往队伍后面走，发现是一群小屁孩，直接全部撵走，然后排在了社会大佬们的后面。
那么这就是一个单调递减的栈，按实力递减。由于栈元素是后进先出的，
所以上面的例子正确的检查顺序应该是从队尾往前遍历，小屁孩都撵走，直到遇到大佬停止，然后排在大佬后面（
假设这个队列已经事先按实力递减排好了）。

单调栈的一大优势就是线性的时间复杂度，所有的元素只会进栈一次，而且一旦出栈后就不会再进来了。

单调递增栈可以找到左起第一个比当前数字小的元素。
单调递减栈可以找到左起第一个比当前数字大的元素。

分析它的时间复杂度，要从整体来看：总共有 n 个元素，每个元素都被 push 入栈了一次，
而最多会被 pop 一次，没有任何冗余操作。所以总的计算规模是和元素规模 n 成正比的，也就是 O(n) 的复杂度。
有时取的结果不是下一个更大的元素是多少，而是索引或者距离，则stack中存入的是index



单调栈(https://www.jianshu.com/p/6bbd3653a57f)
单调栈分为单调递增栈和单调递减栈 (从栈顶往下看递增还是递减)


操作规则（下面都以单调递减栈为例）
1. 如果新的元素比栈顶元素大，就入栈
2. 如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小

加入这样一个规则之后，会有什么效果
1. 栈内的元素是递减的（从栈顶往下看）
2. 当元素出栈时，说明这个新元素是出栈元素向后找第一个比其大的元素
3. 当元素出栈后，说明新栈顶元素是出栈元素向前找第一个比其小的元素

代码模板
单调递减栈： 能表示入栈元素左边第一个比它小的元素
        Deque<Integer> s = new LinkedList<>();
        int i = 0;
        while (i < nums.length) {
            if (s.isEmpty() || nums[s.peek()] <= nums[i])//可能会更大，因此往后走
                s.push(i++);//如果只关注数值可以直接存入数值，如果关注idx之间的距离，也就是和最值的距离，则存入idx
            else {
                //另外注意在处理最值的时候是不动i的
                tp = s.pop();  // 为了维护单调递减放入新元素，要先处理大的栈顶
                做处理
            }
        }

        while (!s.isEmpty()) {
            tp = s.pop();
        }

单调递增栈：能表示入栈元素左边第一个比它大的元素
        Deque<Integer> s = new LinkedList<>();
        int i = 0;
        while (i < nums.length) {
            if (s.isEmpty() || nums[i] < nums[s.peek()])//可能会更小，因此往后走
                s.push(i++);//如果只关注数值可以直接存入数值，如果关注idx之间的距离，也就是和最值的距离，则存入idx
            else {
                //另外注意在处理最值的时候是不动i的
                tp = s.pop();  // store the top index
                做处理
            }
        }

        while (!s.isEmpty()) {
            tp = s.pop();
        }


LC相关题目：
496 (递增栈)
84 （递减栈）
739
901
768/769 (递减栈)
42 （递增栈）
907
402

技巧1：循环单调栈
将原始数组“翻倍”，就是在后面再接一个原始数组，
这样的话，按照之前“比身高”的流程，每个元素不仅可以比较自己右边的元素，而且也可以和左边的元素比较了。
LC相关题目：
503  (循环数组直接扩两倍，然后在取下标的时候记得)

