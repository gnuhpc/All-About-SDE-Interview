TopK问题一般有两种情况: 求第K个最大的/求前K个最大的

方法1：使用PriorityQueue (首选，通解)
记忆要点:求最大的k个数 则用最小堆,反之用最大堆
步骤:(以求最大k为例)
1) 构建最小堆
2) 往里面依次添加元素,直到堆的size 等于k, 堆顶放的就是最小的数字,也就是最可能被淘汰的
3) 接着取数字,如果发现取出来的数字比堆顶大,说明堆顶的数字不是最终结果,因此poll出来,然后将新取的数字塞进去,由于堆的特性,堆顶还是最小的,
   也就是最可能被淘汰的.
4) 如此往复存下其余数字, 最后堆里面剩下的k个数字便是最大的k个数,而堆顶就是第K个最大的数

时间复杂度O(nlog(k))
空间复杂度O(k)

LC相关题目:
347
215
373
378
668
719
786

方法2：使用quickselect (只能求第k个小的) 见QuickSelect.java
给定一个数组nums和一个k,求第k个小的元素
1)首先进行partition,目标是将数组分为两部分
    1-1: 取得pivot的idx和值,一般取low的地方,pivot作为分割的标尺
    1-2: 设置两个游标p和q,开始从两边向中间遍历(p<=q), p遇到比pivot的值大的停下,q遇到比pivot小的停下,然后交换.
         注意要一直判断p<=q
    1-3: 最终在q和pivotIdx交换数值.至此,数组被分为前边部分小于pivot,后半部分大于等于pivot,而分界点即为q.
2)返回这个分界点q,如果为k -1 等于q,则说明这个位置的数值正好第k个小的元素,否则q如果大于k-1说明要向左找,否则向右找

LC相关题目:
215
324

方法3：使用桶排序，将freq=i的元素映射到List[i]中
LC相关题目：
347 Method2
692 Method2

方法4：使用排序对所有元素进行排序求解

1. 衍生出来的一个问题是如何查找一个数字的中位数：
findKthLargest(nums, (nums.length + 1) / 2);

2. 对于一个map而言，如果需要对他的key进行排序，则可以在comparator中对value进行比较
LC相关题目：
347 Method1

3. 在用自定义comparator的时候别忘了在后边比较堆顶的时候用同样的comparator
queue.comparator().compare(key, queue.peek()) > 0
LC相关题目
692 Method1
