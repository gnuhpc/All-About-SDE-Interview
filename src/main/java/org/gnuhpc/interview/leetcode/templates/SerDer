序列化

一般序列化有两种做法

1) 一种是BFS，逐行进行。不管一个节点有多少个子节点，在序列化中都将其子节点放入一个#中

序列化：
1. 先将root的值放入队列,然后放入",#,"
2. 随后进行层次遍历,对同一个节点下边的子节点进行逗号分割, 该组子节点结束的时候放入"#,"作为结束的标识
3. 最后sb.toString()输出结果

反序列化：
1. 先根据逗号分割字符串
2. 将root构造出来放入queue
3. 使用idx = 1进行节点数量控制 然后从queue中poll元素，idx++跳过#，
   通过for循环构造子节点，过程中接着放入queue

LC相关题目：
428 解法1 是通解
297 解法1 注意与428对于NULL的处理差异

2) 一种是DFS，相当于preorder，记录每个节点的子节点个数（如果不定的话）

序列化:
使用一个helper函数递归构造，先将root的值和子节点个数 (在处理个数的时候注意子树区分左右)放入sb，如果有孩子节点则进行递归遍历。
注意：如果是null则放入X，不计子节点个数

反序列化：
以逗号分割后用一个全局变量p作为offset指针， 整个过程中只要用到p统统++操作
逻辑上分为是否为X，如果是则返回null ， 如果不是则取出size，然后构造节点n，对于n的子节点递归插入

LC相关题目：
428 是通解
297 解法2 是428的变种
449 是297的特例，也可以直接用297的解
